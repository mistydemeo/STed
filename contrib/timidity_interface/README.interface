STed for UNIX の外部プレーヤー呼び出し時の動作について

      ------------------------------------------

STed は、実際に MIDI 機器を操作する事は（ほとんど）ありません。
エディット中の演奏などは、外部の SMF/RCP player を呼び出す事により
行っています。このため、使用する MIDI デバイス毎に ユーザー側で player を
用意することができ、より多くの環境に柔軟に対応する事ができるようになって
います。

通常 STed は、外部 player に対し内部演奏データを SMF ファイルの形で
渡し (player が RCP/R36 ファイルを解釈できる場合 (sted2.cnf で
設定される) は RCP ファイルの形で渡します)、外部 player にそのファイルを
演奏するよう指示 (fork) した後は、演奏を停止する / 演奏が停止するまでは
player に対する操作は一切行いません。放ったらかしです。
このため、通常の場合、一時停止などの player との通信が必要な処理は行うこと
ができません。

しかし player によっては、STed とのインタフェイスを持ち、演奏中の一時停止・
解除・演奏位置トレースなどの処理を行うことが出来ます。このインタフェイスは、
STed と player の間で共有メモリを介して情報を交換する事により実現されて
います。オリジナルである X680x0 でも、同様な方法で 専用 player(rcd.x) と
協調動作を行っていました。

このドキュメントでは、player に対し STed とのインタフェイスを実装するための
方法を紹介しています。

      ------------------------------------------

インタフェイスの動作は、基本的には以下のようになります:

 1. STed が 必要な共有メモリ・ファイル・環境変数などを設定する
 2. player が fork される。演奏データはファイルとして出力されるか、
    共有メモリ上に置かれる
 3. player は環境変数 (STED_RCD_SHMID) から共有メモリの ID を得て、
    共有メモリにアクセスする
 4. player が自身の演奏状態に合わせ、共有メモリ上の各変数を設定する
 5. STed は、共有メモリ上の変数を見て様々な動作を行う。また、player 操作の
    ため必要な情報を書き込む
 6. 演奏が停止する/演奏を停止させると、STed が player を看取る(wait)。
    あるいは次の演奏まで player は待機する
 7. STed が終了する段階で、共有メモリは破棄される。player 側が共有メモリの
    処理に付いて考える必要は無い

共有メモリは、STed 内で使用される RCD_HEAD 構造体そのものです。構造体の
内容に付いては rcddef.h を参照して下さい。また、この構造体を操作する
わけですから、player を作る際には当然 rcddef.h をインクルードする必要が
あります。
このインタフェイスで使用する構造体メンバは以下の通りです。構造体名は rcd と
します:

  (data_adr)      : RCP データの先頭位置
  (smf_adr)       : SMF データの先頭位置
  rcd->totalcount : RCP/SMF データの大きさ（ヘッダ含む）

  data_adr = (char *)rcd+sizeof(struct RCD_HEAD)
  smf_adr  = data_adr + DATA_ADR_SIZE

   RCP ファイルを演奏できる player の場合、データをファイルからではなく
   直接メモリ上から引き出すことが出来ます。この場合、sted2.cnf の
   #player の第一引数のビット 0 が 0 になっている必要があります。
   データは data_adr から rcd->totalcount バイト分並んでいます。データを
   読み込んでいる間は rcd->act の値を 2 にしてください。data_adr の内容が
   ロックされ、STed 側で書き込めなくなります。
   このとき、データは player の内部バッファに読み込み、なるべく rcd->act が
   2 になっている時間を短くするようにして下さい。演奏中でも STed では
   エディットが可能ですので。
   なお、SMF player の場合でも、同様に smf_adr からデータを読むことが
   出来ます。わざわざ SMF データを別の領域に確保しているのは、data_adr は
   STed でのエディット用バッファも兼ねているためです。

   DATA_ADR_SIZE および SMF_ADR_SIZE は、それぞれ data_adr と smf_adr を
   先頭とするバッファのサイズです。STed 内部で、この大きさだけ malloc で
   確保されています。rcddef.h で定義されています。


  rcd->act          : player の状態
  rcd->sts          : 一時停止(1) 演奏中(0)

   rcd->act は STed 側で設定されます。この値が 0 から 1 に変わったとき
   演奏を開始し、1 から 0 になった時演奏を停止するようにしてください。
   また、上記の通り、[data,smf]_adr の内容をロックしたい場合は、この値を
   2 に設定してください。
   rcd->sts は見てそのままです。STed 側から設定されます。

  rcd->stepcount  : 演奏開始時からのステップ数
  rcd->bar[track] : 演奏開始時からの小節番号（トラック毎）
  rcd->step[track]: 小節内でのイベント数（トラック毎）

   エディット時に CAPS キーで起動される演奏トレース機能のための変数です。
   STed では、この値を見て現在データ中のどの位置が演奏されているかを
   調べます。rcd->stepcount については、演奏トレース以外でも使用されて
   います。
   rcd->bar[??] と rcd->step[??] については、処理が面倒な場合は
   rcd->stepcount だけの設定でもトレース動作は可能です。この場合、
   rcd->stepcount の値が変わる毎に rcd->bar[]、rcd->step[] の全てに
   -1 を代入してください。track の値は、0 <= track < TRK_NUM (rcddef.h
   で定義) です。

なお、これ以外のエントリに付いては、参照はともかく書き換えは行わないように
してください。

      ------------------------------------------


実際の動作に付いて以下に示します:

1. 環境変数
    STed for UNIX (以下単に STed) は外部プレーヤー呼び出し時に
   環境変数 STED_RCD_SHMID をセットします。変数の内容は ASCII 形式
   の十進数となっており、atoi() などの関数により STed の使用する
   共有メモリーの id を得ることができます。

  例)
    #include "rcddef.h"
    struct RCD_HEAD *rcd =
        (struct RCD_HEAD *)shmat(atoi(getenv("STED_RCD_SHMID")), 0, 0);

2. 引数
    sted2.cnf の #player の第一引数の bit1 が 0 の場合、演奏すべきファイル
   名が引数として player に渡されます。それ以外の場合、演奏データは共有
   メモリから読み出すことになり、引数の値は "shm:" になります。

    #player=2,fooplayer

   は、演奏データを共有メモリから読み込みます。一応、引数の値を見て
   どこからデータを読み込むべきかを判断した方が賢明でしょう。
   共有メモリ経由の場合、演奏データは
     rcd->data_adr (RCP の場合)
     rcd->smf_adr  (SMF の場合)
   を先頭に rcd->totalcount bytes の長さだけあります。

3. 制御
    sted2.cnf の #player の第一引数の bit1 が 0 の場合、演奏開始時に
   毎回 #player が呼び出され(fork)、演奏停止時には kill により終了します。
   bit1 が 1 の場合、#player の呼び出しは最初の 1 回だけで、その後は
   共有メモリ上から必要なデータを読みつつ演奏処理を行う/停止することに
   なります。そのため、演奏が終わっても終了しないようにする必要があります。
   2 回目からは rcd->act を監視し、この値が 0 から 1 に変化したところで
   演奏を開始し、1 から 0 に変化したところで演奏を終了します。

  例) 間違っても
     while(rcd->act==0){};
     start_play();
   なんてことはやらないように。ものすごく処理が重くなります。正解は
     whle(rcd->act==0){usleep(100000)}; /* 100 msec */
     start_play();
   といった感じ。

    演奏データの読み込み中、rcd->data_adr、rcd->smf_adr の内容をロック
   したい場合は、rcd->act の値を 2 にしてください。rcd->[data,smf]_adr の
   内容は player の内部バッファに読み込み、rcd->[data,smf]_adr をそのまま
   使い続けないようにしてください。
    rcd->sts の値は、0 で演奏中 1 で一時停止を示します。

    rcd->bar[track] は track における小節番号 (トラックエディターの
   MEAS で示される値 -1) を示すためのもので、rcd->step[track] は
   track におけるステップ番号 (トラックエディターの STEP で示される値)を
   示すためのものです。現在演奏中の値を設定することにより、STed は
   トレース表示を行うことができます。全トラックについて値を設定してください。
   演奏を行っていないトラックに付いては、それぞれ 0 を代入してください。

    小節番号やトラック番号の管理が出来ない(SMF player など)場合は、
   rcd->stepcount に演奏開始時からのステップ数を代入し、rcd->bar[]、
   rcd->step[] の全てに -1 を代入して下さい。STed 内部で自動的に各トラック
   毎のステップ数、小節数を計算します。
   但し、多少計算量のある処理、かつ誤差もあるので、出来れば player 側で
   小節管理を行って下さい。

  例)
    rcd->stepcount = player_totalcount;
    for ( i=0 ; i<TRK_NUM ; i++ ) {
      rcd->bar[i]=-1;
      rcd->step[i]=-1;
    }
   
    rcd->bar[track]、rcd->step[track] に値を設定する場合でも、rcd->stepcount
   への値の設定は必須です。リアルタイムレコーディング時にこの値を使用して
   います。


インタフェイスの実装は、ほぼ全て木下浩介さん(kino@krhm.jvc-victor.co.jp)
の手に依ります。

